-- this module is for the "inscribed" data type, basically any other
-- type with a string to describe it. I will use it for logging the history
-- of player's actions in the play page, and giving the operations
-- in the level page a name so that I can display them on buttons later


module Inscribed exposing (..)

import Operation exposing (Operation)


type Inscribed a
    = InscribedData a String


extractMessage : Inscribed a -> String
extractMessage (InscribedData _ msg) =
    msg


extractValue : Inscribed a -> a
extractValue (InscribedData val _) =
    val



-- this function basically adds a message generated by another
-- function to an already existing inscribed thing


bind : (a -> Inscribed b) -> Inscribed a -> Inscribed b
bind fn (InscribedData oldValue oldMessage) =
    let
        -- unfortunately elm doesn't let me directly pattern match here
        newInscribed =
            fn oldValue

        (InscribedData newValue newMessage) =
            newInscribed
    in
    InscribedData newValue (oldMessage ++ newMessage)


map : (a -> b) -> Inscribed a -> Inscribed b
map fn (InscribedData val message) =
    let
        newVal =
            fn val
    in
    InscribedData newVal message



-- I'm sure there's a proper name for this. This function is used for
-- logging the player's actions in the play page. For example, if you had
-- an operation that adds one called "increment", and you put it through
-- this, you'd get a function that adds one to the given number, and
-- adds the message "increment x to get result"


type BindableFunction
    = IntFunction (Int -> Inscribed Int)
    | FloatFunction (Float -> Inscribed Float)


makeBindable : Inscribed Operation -> BindableFunction
makeBindable (InscribedData operation name) =
    case operation of
        Operation.FloatFunction fn ->
            let
                returnFunction : Float -> Inscribed Float
                returnFunction n =
                    let
                        result =
                            fn n
                    in
                    InscribedData result <|
                        (" " ++ name ++ " " ++ String.fromFloat n ++ " to get " ++ String.fromFloat result ++ ";")
            in
            FloatFunction returnFunction

        Operation.IntFunction fn ->
            let
                returnFunction : Int -> Inscribed Int
                returnFunction n =
                    let
                        result =
                            fn n
                    in
                    InscribedData result <|
                        (" " ++ name ++ " " ++ String.fromInt n ++ " to get " ++ String.fromInt result ++ ";")
            in
            IntFunction returnFunction
